(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{416:function(t,e,r){"use strict";r.r(e);var a=r(51),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"栈协调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈协调"}},[t._v("#")]),t._v(" 栈协调")]),t._v(" "),r("h3",{attrs:{id:"启发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#启发"}},[t._v("#")]),t._v(" 启发")]),t._v(" "),r("ul",[r("li",[t._v("Diff性能突破关键在于分层对比")]),t._v(" "),r("li",[t._v("类型一致的Node才有继续Diff的必要性")]),t._v(" "),r("li",[t._v("key帮助我们尽可能的重用同一层级的节点")])]),t._v(" "),r("h3",{attrs:{id:"分层对比-改变时间复杂度的决定性思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层对比-改变时间复杂度的决定性思路"}},[t._v("#")]),t._v(" 分层对比：改变时间复杂度的决定性思路")]),t._v(" "),r("h3",{attrs:{id:"类型一致-减少递归-一刀切-的思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型一致-减少递归-一刀切-的思路"}},[t._v("#")]),t._v(" 类型一致：减少递归“一刀切”的思路")]),t._v(" "),r("h3",{attrs:{id:"key属性-重用节点的关键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#key属性-重用节点的关键"}},[t._v("#")]),t._v(" key属性：重用节点的关键")]),t._v(" "),r("h3",{attrs:{id:"问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),r("p",[t._v("栈协调机制下的"),r("code",[t._v("Diff")]),t._v("算法，其实是"),r("strong",[t._v("树的深度优先遍历过程")]),t._v("，也就是一个"),r("strong",[t._v("同步的递归过程")]),t._v("，意味着一旦更新开始，根本停不下来。当处理复杂度高、体量大的虚拟"),r("code",[t._v("DOM")]),t._v("树时，栈协调需要的调和时间会很长，意味着"),r("strong",[t._v("JavaScript 对主线程将长时间占用")]),t._v("，进而导致渲染卡顿、无响应等问题")]),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"fiber协调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber协调"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://www.xujun.org/note-131146.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fiber协调"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("是实现"),r("strong",[t._v("增量渲染")]),t._v("，换句话说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里，是一种手段。目的，是为了实现任务的"),r("strong",[t._v("可中断、可恢复")]),t._v("，并给不同的任务赋予不同的"),r("strong",[t._v("优先级")]),t._v("，最终达到快速响应的体验")]),t._v(" "),r("h3",{attrs:{id:"fiber核心-可中断、可恢复、不同的优先级"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber核心-可中断、可恢复、不同的优先级"}},[t._v("#")]),t._v(" Fiber核心：可中断、可恢复、不同的优先级")]),t._v(" "),r("p",[t._v("相对于栈协调，Fiber协调多出了调度器"),r("code",[t._v("Scheduler")]),t._v("，其更新的处理工作变成了")]),t._v(" "),r("ul",[r("li",[t._v("每个更新任务都会赋予一个优先级")]),t._v(" "),r("li",[t._v("当更新任务抵达调度器时，高优先级的更新任务(A)会更快地被调度进入 "),r("code",[t._v("Reconciler")]),t._v(" —— "),r("strong",[t._v("优先级")])]),t._v(" "),r("li",[t._v("此时有新的更新任务(B)，调度器会检查它优先级，若高于当前任务(A)，处于当前"),r("code",[t._v("Reconciler")]),t._v("层的A任务会被中断，调度器将B任务推入"),r("code",[t._v("Reconciler")]),t._v("层 —— "),r("strong",[t._v("可中断")])]),t._v(" "),r("li",[t._v("当B任务完成渲染后，新一轮调度开始，之前被中断的A任务将会被重新推入"),r("code",[t._v("Reconciler")]),t._v("层，继续它的渲染 —— "),r("strong",[t._v("可恢复")])])]),t._v(" "),r("h3",{attrs:{id:"react架构分层和生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react架构分层和生命周期"}},[t._v("#")]),t._v(" React架构分层和生命周期")]),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"理解fiber协调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解fiber协调"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://www.jianshu.com/p/22d4d3eed8c0",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解Fiber协调"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"博文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#博文"}},[t._v("#")]),t._v(" 博文")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zoo.team%2Farticle%2Fabout-react-fiber",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端工程师的自我修养：React Fiber 是如何实现更新过程可控的"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"react如何实现快速响应"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react如何实现快速响应"}},[t._v("#")]),t._v(" React如何实现快速响应")]),t._v(" "),r("ul",[r("li",[t._v("CPU的瓶颈：当项目变得庞大、组件数量繁多、遇到"),r("strong",[t._v("大计算量")]),t._v("的操作或者"),r("strong",[t._v("设备性能不足")]),t._v("使得页面掉帧，导致卡顿。（引入"),r("strong",[t._v("Time Slicing 时间分片")]),t._v("概念）")]),t._v(" "),r("li",[t._v("IO的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。（引入"),r("strong",[t._v("Suspense")]),t._v("概念）")])]),t._v(" "),r("h3",{attrs:{id:"react的-先天不足-听说-vue-3-0-采用了动静结合的-dom-diff-react-为何不跟进"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react的-先天不足-听说-vue-3-0-采用了动静结合的-dom-diff-react-为何不跟进"}},[t._v("#")]),t._v(" React的“先天不足” —— 听说 "),r("a",{attrs:{href:"https://blog.csdn.net/frontend_frank/article/details/114297890",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 3.0 采用了动静结合的 Dom diff"),r("OutboundLink")],1),t._v("，React 为何不跟进？")]),t._v(" "),r("h3",{attrs:{id:"从架构演变看不断进击的-react-都做过哪些优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从架构演变看不断进击的-react-都做过哪些优化"}},[t._v("#")]),t._v(" 从架构演变看不断进击的 React 都做过哪些优化？")]),t._v(" "),r("h4",{attrs:{id:"react渲染页面的两个阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react渲染页面的两个阶段"}},[t._v("#")]),t._v(" React渲染页面的两个阶段")]),t._v(" "),r("ul",[r("li",[t._v("调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，"),r("strong",[t._v("得到新的更新队列")]),t._v("。")]),t._v(" "),r("li",[t._v("渲染阶段（commit）：这个阶段 React 会遍历更新队列，"),r("strong",[t._v("将其所有的变更一次性更新到DOM上")]),t._v("。")])]),t._v(" "),r("h4",{attrs:{id:"react-15-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-15-架构"}},[t._v("#")]),t._v(" React 15 架构")]),t._v(" "),r("p",[t._v("React15架构可以分为两层：")]),t._v(" "),r("ul",[r("li",[t._v("Reconciler（协调器）—— 负责找出变化的组件；")]),t._v(" "),r("li",[t._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上；")])]),t._v(" "),r("p",[t._v("在React15及以前，Reconciler采用递归的方式创建虚拟DOM，"),r("strong",[t._v("递归过程是不能中断的")]),t._v("。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。")]),t._v(" "),r("h4",{attrs:{id:"react16架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16架构"}},[t._v("#")]),t._v(" React16架构")]),t._v(" "),r("p",[t._v("React16架构可以分为三层：")]),t._v(" "),r("ul",[r("li",[t._v("Scheduler（调度器）—— "),r("strong",[t._v("调度任务的优先级")]),t._v("，高优任务优先进入Reconciler；")]),t._v(" "),r("li",[t._v("Reconciler（协调器）—— 负责找出变化的组件："),r("strong",[t._v("更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构")]),t._v("；")]),t._v(" "),r("li",[t._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上。")])]),t._v(" "),r("h4",{attrs:{id:"react-17-优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-17-优化"}},[t._v("#")]),t._v(" React 17 优化")]),t._v(" "),r("p",[t._v("React16的"),r("strong",[t._v("expirationTimes模型")]),t._v("只能区分是否"),r("code",[t._v(">=expirationTimes")]),t._v("决定节点是否更新。React17的"),r("strong",[t._v("lanes模型")]),t._v("可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。")]),t._v(" "),r("h3",{attrs:{id:"浏览器一帧都会干些什么以及requestidlecallback的启示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器一帧都会干些什么以及requestidlecallback的启示"}},[t._v("#")]),t._v(" 浏览器一帧都会干些什么以及requestIdleCallback的启示")]),t._v(" "),r("h4",{attrs:{id:"浏览器一帧都会干些什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器一帧都会干些什么"}},[t._v("#")]),t._v(" 浏览器一帧都会干些什么？")]),t._v(" "),r("p",[t._v("目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的（16.6ms） 过程中浏览器又干了些什么呢？")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("接受输入事件")])]),t._v(" "),r("li",[r("p",[t._v("执行事件回调")])]),t._v(" "),r("li",[r("p",[t._v("开始一帧")])]),t._v(" "),r("li",[r("p",[t._v("执行 RAF (RequestAnimationFrame)")])]),t._v(" "),r("li",[r("p",[t._v("页面布局，样式计算")])]),t._v(" "),r("li",[r("p",[t._v("绘制渲染")])]),t._v(" "),r("li",[r("p",[t._v("执行 RIC (RequestIdelCallback)")]),t._v(" "),r("blockquote",[r("p",[t._v("RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。")])])])]),t._v(" "),r("h3",{attrs:{id:"requestidlecallback-的启示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#requestidlecallback-的启示"}},[t._v("#")]),t._v(" requestIdleCallback 的启示")]),t._v(" "),r("p",[t._v("Facebook 抛弃了 requestIdleCallback 的原生 API, 实现了功能更完备的requestIdleCallbackpolyfill：")]),t._v(" "),r("ul",[r("li",[t._v("浏览器兼容性；")]),t._v(" "),r("li",[t._v("触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低。")])]),t._v(" "),r("blockquote"),t._v(" "),r("p",[t._v("参考")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fissues%2F13206",target:"_blank",rel:"noopener noreferrer"}},[t._v("requestIdleCallback 的 FPS 只有 20"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.zhangyunling.com%2F702.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("requestIdleCallback-后台任务调度"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"fiber-为什么是-react-性能的一个飞跃"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-为什么是-react-性能的一个飞跃"}},[t._v("#")]),t._v(" Fiber 为什么是 React 性能的一个飞跃？")]),t._v(" "),r("h4",{attrs:{id:"react-fiber-中的时间分片"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-中的时间分片"}},[t._v("#")]),t._v(" React Fiber 中的时间分片")]),t._v(" "),r("h4",{attrs:{id:"fiber链表结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber链表结构"}},[t._v("#")]),t._v(" Fiber链表结构")]),t._v(" "),r("p",[t._v("链表相比顺序结构数据格式的"),r("strong",[t._v("好处")]),t._v("就是：")]),t._v(" "),r("ol",[r("li",[t._v("操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。")]),t._v(" "),r("li",[t._v("不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。")])]),t._v(" "),r("p",[t._v("但链表也不是完美的，"),r("strong",[t._v("缺点")]),t._v("就是：")]),t._v(" "),r("ol",[r("li",[t._v("比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。")]),t._v(" "),r("li",[t._v("不能自由读取，必须找到他的上一个节点。")])]),t._v(" "),r("p",[t._v("React 用"),r("strong",[t._v("空间换时间")]),t._v("，更高效的操作可以方便根据优先级进行操作。同时"),r("strong",[t._v("可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"react-fiber-是如何实现更新过程可控"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-是如何实现更新过程可控"}},[t._v("#")]),t._v(" React Fiber 是如何实现更新过程可控？")]),t._v(" "),r("p",[t._v("Fiber核心：可中断、可恢复、不同的优先级")])])}),[],!1,null,null,null);e.default=_.exports}}]);